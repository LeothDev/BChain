public class Blockchain {
    private List<List<Block>> forks;

    public Blockchain() {
        forks = new ArrayList<>();
        forks.add(new ArrayList<>()); // add the genesis block
    }

    public void addBlock(Block block) {
        List<Block> longestFork = getLongestFork();
        if (block.getPreviousBlockHash().equals(longestFork.get(longestFork.size() - 1).getHash())) {
            // the new block extends the longest fork
            longestFork.add(block);
        } else {
            // the new block creates a new fork
            List<Block> newFork = new ArrayList<>();
            newFork.addAll(longestFork.subList(0, longestFork.indexOf(getCommonAncestor(block)) + 1));
            newFork.add(block);
            forks.add(newFork);
        }
    }

    private List<Block> getLongestFork() {
        return forks.stream().max(Comparator.comparingInt(List::size)).orElseThrow();
    }

    private Block getCommonAncestor(Block block) {
        for (int i = forks.size() - 1; i >= 0; i--) {
            List<Block> fork = forks.get(i);
            for (int j = fork.size() - 1; j >= 0; j--) {
                if (fork.get(j).getHash().equals(block.getPreviousBlockHash())) {
                    return fork.get(j);
                }
            }
        }
        // should never happen since the genesis block is always in the list
        throw new RuntimeException("Cannot find common ancestor");
    }
}
