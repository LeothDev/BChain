import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class User extends Thread {
    private Wallet wallet;
    private Blockchain longest_chain;
    private Lock lock;
    private Condition condition;

    public User(Wallet wallet, Blockchain longest_chain) {
        this.wallet = wallet;
        this.longest_chain = longest_chain;
        this.lock = new ReentrantLock();
        this.condition = lock.newCondition();
    }

    public void run() {
        while (!isInterrupted()) {
            try {
                // check if the user has enough money to perform the transaction
                if (wallet.get_balance() >= 1) {
                    // perform a transaction
                    do_transaction(longest_chain);

                    lock.lock();
                    try {
                        // wait for broadcast from miner
                        condition.await();
                        // choose the longest chain
                        if (longest_chain.size() < Blockchain.sharedBlockchain.size()) {
                            longest_chain = Blockchain.sharedBlockchain.getCopy();
                        }
                    } finally {
                        lock.unlock();
                    }

                    // sleep for a random amount of time
                    Thread.sleep(generateRandomIntInRange(10, 200));
                } else {
                    System.out.println("User " + this.getId() + " does not have enough money to perform transaction.");
                    Thread.sleep(generateRandomIntInRange(10, 200));
                }

            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    private void do_transaction(Blockchain chain) {
        // create a new transaction
        Transaction tx = new Transaction(wallet.get_public_key(), "receiver_address", 1);

        // add the transaction to the mempool
        chain.get_mempool().add_transaction(tx);

        System.out.println("User " + this.getId() + " created a new transaction: " + tx);
    }

    public void receive_broadcast(Blockchain new_chain) {
        lock.lock();
        try {
            // set the shared blockchain to the new chain
            Blockchain.sharedBlockchain = new_chain;
            // signal the waiting user
            condition.signalAll();
        } finally {
            lock.unlock();
        }
    }

    // utility method to generate a random integer within a range
    private int generateRandomIntInRange(int min, int max) {
        return (int) (Math.random() * ((max - min) + 1)) + min;
    }
}
