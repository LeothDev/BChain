Sure, here's an example implementation:

```
import java.util.ArrayList;
import java.util.concurrent.locks.ReentrantLock;

public class Blockchain {
    private ArrayList<Block> blockchain;
    private ArrayList<Transaction> mempool;
    private ReentrantLock lock;

    public Blockchain() {
        this.blockchain = new ArrayList<Block>();
        this.mempool = new ArrayList<Transaction>();
        this.lock = new ReentrantLock();
    }

    //public synchronized void addTransactionToMemoryPool(Transaction transaction) {
        //this.mempool.add(transaction);
    //}

    public void addTransactionToMemoryPool(Transaction transaction) {
        synchronized (memoryPool) {
            memoryPool.add(transaction);
        }
    }


    public void mineBlock(int minerId) {
        lock.lock();
        try {
            // check if another miner is already mining the block
            // if another miner is already mining, exit the function
            if (blockchain.get(blockchain.size()-1).getMinerId() != -1) {
                return;
            }

            // get the previous block's hash
            String previousBlockHash = blockchain.get(blockchain.size()-1).getBlockHash();

            // create the new block and add it to the blockchain
            Block newBlock = new Block(previousBlockHash, minerId, mempool);
            blockchain.add(newBlock);

            // clear the memory pool
            mempool.clear();
        } finally {
            lock.unlock();
        }
    }
}
```

In this example, `Blockchain` is a shared data structure between User and Miner threads.
It contains the blockchain and the memory pool, which are both accessed and modified by
both types of threads. The `synchronized` keyword is used to ensure that access to the
memory pool is synchronized between User threads. The `ReentrantLock` class is used to
ensure that only one Miner thread is mining a block at a time.

The `mineBlock` method takes an argument `minerId` to identify the Miner thread that is
mining the block. The method uses a lock to ensure that only one Miner thread is mining
the block at a time. If another Miner thread is already mining the block, the method simply
 exits without doing anything.

The `addTransactionToMemoryPool` method is synchronized to ensure that access to the memory
pool is synchronized between User threads.

Regarding the competition between miners, the goal of the blockchain network is to achieve
consensus, which means that all nodes in the network agree on the state of the blockchain.
In order to achieve this, miners compete to be the first to solve the cryptographic puzzle
and create a new block. However, once a block is created, it is added to the blockchain and
 becomes part of the network's consensus. If multiple miners were allowed to mine the same
 block, it could result in conflicts and undermine the integrity of the blockchain.