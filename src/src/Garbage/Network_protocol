{
    "type": "transaction",
    "from": "user1",
    "to": "user2",
    "amount": 10
}

{
    "type": "blockchain",
    "blocks": [
        {
            "index": 0,
            "timestamp": 1631278228.6171942,
            "transactions": [],
            "proof": 100,
            "previous_hash": "1"
        },
        {
            "index": 1,
            "timestamp": 1631278252.8696215,
            "transactions": [
                {
                    "from": "user1",
                    "to": "user2",
                    "amount": 10
                }
            ],
            "proof": 35293,
            "previous_hash": "a08f3c5dcb6f5e381f55ec1da1f3e83335b8e4a98c22dbb7a9a8805cc0b25df5"
        }
    ]
}








import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.Socket;

public class User extends Thread {
    private final String name;
    private final Wallet wallet;
    private final Socket socket;

    public User(String name, Wallet wallet, Socket socket) {
        this.name = name;
        this.wallet = wallet;
        this.socket = socket;
    }

    @Override
    public void run() {
        try {
            BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));
            PrintWriter out = new PrintWriter(socket.getOutputStream(), true);

            while (true) {
                // check if the user has enough money to perform the transaction
                if (wallet.get_balance() >= 1) {
                    // perform a transaction
                    out.println("{ \"type\": \"transaction\", \"from\": \"" + name + "\", \"to\": \"user2\", \"amount\": 10 }");
                }
                else {
                    System.out.println("User " + name + " does not have enough money to perform transaction.");
                }

                // sleep for a random amount of time
                Thread.sleep(generateRandomIntInRange(10, 200));
            }
        } catch (IOException | InterruptedException e) {
            e.printStackTrace();
        }
    }
}










import java.io.*;
import java.net.*;

public class Miner extends Thread {
    private int id;
    private Blockchain longest_chain;
    private ServerSocket serverSocket;
    private Socket clientSocket;
    private PrintWriter out;
    private BufferedReader in;

    public Miner(int id, Blockchain longest_chain) {
        this.id = id;
        this.longest_chain = longest_chain;
    }

    public void run() {
        try {
            // open server socket
            serverSocket = new ServerSocket(6000 + id);

            while (true) {
                // wait for incoming connection from user
                clientSocket = serverSocket.accept();

                // receive message from user
                in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));
                String message = in.readLine();

                // update longest chain
                if (message != null) {
                    Blockchain new_chain = Blockchain.fromString(message);
                    if (new_chain.size() > longest_chain.size()) {
                        longest_chain = new_chain;
                    }
                }

                // close connection
                clientSocket.close();
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public void broadcast(Block block) {
        try {
            // create socket and send message to all users
            for (int i = 1; i <= 5; i++) {
                Socket socket = new Socket("localhost", 6000 + i);
                out = new PrintWriter(socket.getOutputStream(), true);
                out.println(block.toString());
                socket.close();
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

public class User extends Thread {
    private int id;
    private Wallet wallet;
    private Blockchain longest_chain;
    private Socket socket;
    private PrintWriter out;
    private BufferedReader in;

    public User(int id, Wallet wallet, Blockchain longest_chain) {
        this.id = id;
        this.wallet = wallet;
        this.longest_chain = longest_chain;
    }

    public void run() {
        try {
            // open socket and connect to miner
            socket = new Socket("localhost", 6000);

            while (true) {
                // check if the user has enough money to perform the transaction
                if (wallet.get_balance() >= 1) {
                    // perform a transaction
                    do_transaction(longest_chain);

                    // receive message from miner
                    in = new BufferedReader(new InputStreamReader(socket.getInputStream()));
                    String message = in.readLine();

                    // update longest chain
                    if (message != null) {
                        Blockchain new_chain = Blockchain.fromString(message);
                        if (new_chain.size() > longest_chain.size()) {
                            longest_chain = new_chain;
                        }
                    }

                    // sleep for a random amount of time
                    Thread.sleep(generateRandomIntInRange(10, 200));
                }
                else {
                    System.out.println("User " + this.getId() + " does not have enough money to perform transaction.");
                    Thread.sleep(generateRandomIntInRange(10, 200));
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    public void receive_broadcast(Block block) {
        try {
            // connect to miner and send message
            socket = new Socket("localhost", 6000);
            out = new PrintWriter(socket.getOutputStream(), true);
            out.println(block.toString());
            socket.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
